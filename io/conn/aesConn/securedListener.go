package aesConn

import (
	"crypto/aes"
	"crypto/rand"
	"errors"
	"github.com/k773/utils"
	"github.com/k773/utils/io/conn/encryptedConn"
	"net"
	"time"
)

type Listener struct {
	net.Listener
	HandshakeTimeout time.Duration

	AesKey []byte

	// BeforeEncInit is called after an underlying listtener has accepted new connection.
	// If returned error != nil, connection will not be processed but immediately closed.
	BeforeEncInit func(conn net.Conn) error
	// OnEncInitError is called if there was an error during ecryption initialization phase.
	// Error generated by BeforeEncInit will not be passed th this func.
	OnEncInitError func(conn net.Conn, e error)
}

// Accept accepts new connection and encrypts it before returning.
// Any error except underlying listener's won't be returned, instead use Listener.OnEncInitError to handle it.
func (l *Listener) Accept() (net.Conn, error) {
	var conn net.Conn
	var e error
	for e == nil {
		conn, e = l.Listener.Accept()
		if e == nil {
			if e = l.BeforeEncInit(conn); e == nil {
				// Limitting handshake time
				if l.HandshakeTimeout != 0 {
					_ = conn.SetDeadline(time.Now().Add(l.HandshakeTimeout))
				}

				// Handshaking
				if conn, e = UpgradeServer(conn, l.AesKey); e == nil {
					conn.SetDeadline(time.Time{})
					break
				}

				// Reporting connection error
				if e != nil {
					l.OnEncInitError(conn, e)
				}
			}
			// Resetting error; any error during encryption initialization phase should be handled by l.OnEncInitError
			if e != nil {
				_ = conn.Close()
				e = nil
			}
		}
	}
	return conn, e
}

func UpgradeServer(conn net.Conn, aesKey []byte) (_ *encryptedConn.Conn, e error) {
	//return conn, t, nil
	var c = &encryptedConn.Conn{Conn: conn}

	// Client and server already share the same encryption key
	// Handshake:
	// server -> client: [plain/packet]: iv + 32 random bytes
	// client -> server: [enc/packet]: reverse 32 bytes
	// server -> client: [enc/packet]: <empty> / conn close

	var r0 = make([]byte, 32)
	var r = make([]byte, aes.BlockSize+len(r0))
	if _, e = rand.Read(r); e == nil {
		copy(r0, r[aes.BlockSize:])
		if e = c.WritePacket(r); e == nil {
			if e = GenerateCiphers(r[:aes.BlockSize], aesKey, c); e == nil {
				// Checking reversed bytes
				if r, e = c.ReadPacket(); e == nil {
					if len(r) == len(r0) && utils.SliceEvery(r, func(i int) bool { return r[i] == r0[len(r0)-i-1] }) {
						e = c.WritePacket(nil)
					} else {
						e = errors.New("handshake reverse message error")
					}
				}
			}
		}
	}

	return c, e
}
